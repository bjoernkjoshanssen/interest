/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 65b1bbc0-ff19-4807-96fe-48d905e3d801
-/

/-
We proved that for the given parameters i, d, r, there exists a unique positive real number n satisfying the equation.
We defined the function f(n) corresponding to the equation and analyzed its properties.
We showed that f is continuous, strictly decreasing (by analyzing its derivative), starts positive at n=0, and tends to a negative limit as n approaches infinity.
Using the Intermediate Value Theorem and the strict monotonicity, we established the existence and uniqueness of the root.
We also verified that the root is greater than 1, as f(1) > 0.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace AriMagic

/-
Definition of the function f(n) and the auxiliary variable v.
-/
noncomputable def v_def (i : ℝ) : ℝ := (1 + i)⁻¹

noncomputable def f (i d r n : ℝ) : ℝ :=
  let v := v_def i
  d * (r * ((1 - v ^ n) / i) + v ^ n) - (r * (v * (n * v ^ (n + 1) - (n + 1) * v ^ n + 1) / (v - 1) ^ 2) + n * v ^ n)

/-
The function f can be written in a simplified form involving constants C, S, K.
-/
noncomputable def S (i r : ℝ) : ℝ := r / i - 1
noncomputable def K (i d r : ℝ) : ℝ := d * (1 - r / i) + r / (i ^ 2 * v_def i)
noncomputable def C (i d r : ℝ) : ℝ := d * r / i - r / (i ^ 2 * v_def i)
noncomputable def L (i : ℝ) : ℝ := Real.log (v_def i)

lemma f_eq_simplified (i d r n : ℝ) (hi : i ≠ 0) (hv : v_def i ≠ 0) :
  f i d r n = C i d r + (v_def i) ^ n * (S i r * n + K i d r) := by
  unfold f C S K;
  field_simp;
  rw [ Real.rpow_add_one hv ];
  unfold v_def;
  by_cases h : 1 + i = 0 <;> simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm ];
  · unfold v_def at hv; aesop;
  · grind


lemma C_neg (i d r : ℝ) (hi : 0 < i) (hr : 0 < r) (hdi : d < 1 + 1 / i) :
  C i d r < 0 := by
    unfold C;
    unfold v_def;
    field_simp at *;
    nlinarith [ mul_pos hr hi ]

/-
The derivative of f is v^n * g(n).
-/
noncomputable def g (i d r n : ℝ) : ℝ :=
  let v := v_def i
  let S := S i r
  let K := K i d r
  let L := Real.log v
  S * L * n + K * L + S

lemma f_deriv (i d r n : ℝ) (hi : 0 < i) :
  HasDerivAt (f i d r) (v_def i ^ n * g i d r n) n := by
  -- Start by using the definition of f with the simplified form.
  have h_f_simplified : ∀ n, f i d r n = C i d r + (v_def i)^n * (S i r * n + K i d r) := by
    intro n; rw [ f_eq_simplified i d r n hi.ne' ] ; ring_nf;
    exact inv_ne_zero ( by positivity );
  rw [ show f i d r = _ from funext h_f_simplified ] ; convert HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( HasDerivAt.rpow ( hasDerivAt_const _ _ ) ( hasDerivAt_id' n ) _ ) ( HasDerivAt.add ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id' n ) ) ( hasDerivAt_const _ _ ) ) ) using 1 <;> norm_num ; ring_nf!;
  · unfold g; ring;
  · exact inv_pos.mpr ( by positivity )

/-
The limit of f(n) as n approaches infinity is C.
-/
lemma f_tendsto_atTop (i d r : ℝ) (hi : 0 < i) :
  Filter.Tendsto (f i d r) Filter.atTop (nhds (C i d r)) := by
  -- Use the simplified form of f.
  have h_simplified : ∀ n, f i d r n = C i d r + (v_def i) ^ n * (S i r * n + K i d r) := by
    exact fun n => f_eq_simplified i d r n hi.ne' ( by exact ne_of_gt ( inv_pos.mpr ( by linarith ) ) );
  -- Since $0 < v < 1$, $v^n \to 0$ as $n \to \infty$.
  have hv_pow_zero : Filter.Tendsto (fun n : ℝ => (v_def i) ^ n) Filter.atTop (nhds 0) := by
    norm_num [ Real.rpow_def_of_pos, v_def ];
    norm_num [ Real.rpow_def_of_pos ( inv_pos.mpr ( add_pos zero_lt_one hi ) ) ];
    exact Filter.tendsto_id.const_mul_atTop ( Real.log_pos <| by linarith );
  -- Since $0 < v < 1$, $n * v^n \to 0$ as $n \to \infty$.
  have hn_v_pow_zero : Filter.Tendsto (fun n : ℝ => n * (v_def i) ^ n) Filter.atTop (nhds 0) := by
    -- Let $y = n \ln(v_def i)$, so we can rewrite the limit expression as $\lim_{y \to -\infty} y e^y$.
    suffices h_lim_y : Filter.Tendsto (fun y : ℝ => y * Real.exp y) Filter.atBot (nhds 0) by
      have h_subst : Filter.Tendsto (fun n : ℝ => (n * Real.log (v_def i)) * Real.exp (n * Real.log (v_def i))) Filter.atTop (nhds 0) := by
        refine h_lim_y.comp ?_;
        exact Filter.tendsto_atTop_atBot.mpr fun x => ⟨ x / Real.log ( v_def i ), fun n hn => by rw [ div_le_iff_of_neg ( Real.log_neg ( by exact inv_pos.mpr ( by positivity ) ) ( by exact inv_lt_one_of_one_lt₀ ( by linarith ) ) ) ] at hn; linarith ⟩;
      convert h_subst.div_const ( Real.log ( v_def i ) ) using 2 <;> norm_num [ Real.rpow_def_of_pos ( show 0 < v_def i from inv_pos.mpr ( by linarith : 0 < 1 + i ) ), mul_assoc, mul_comm, mul_left_comm ];
      rw [ eq_div_iff ( ne_of_lt ( Real.log_neg ( by exact inv_pos.mpr ( by linarith ) ) ( by exact inv_lt_one_of_one_lt₀ ( by linarith ) ) ) ) ] ; ring;
    -- Let $z = -y$, so we can rewrite the limit expression as $\lim_{z \to \infty} (-z) e^{-z}$.
    suffices h_lim_z : Filter.Tendsto (fun z : ℝ => -z * Real.exp (-z)) Filter.atTop (nhds 0) by
      convert h_lim_z.comp Filter.tendsto_neg_atBot_atTop using 2 ; norm_num;
    simpa using Filter.Tendsto.neg ( Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 1 );
  rw [ Filter.tendsto_congr h_simplified ];
  convert Filter.Tendsto.add tendsto_const_nhds ( Filter.Tendsto.add ( hn_v_pow_zero.const_mul ( S i r ) ) ( hv_pow_zero.const_mul ( K i d r ) ) ) using 2 <;> ring

/-
The function f is continuous on the interval [0, infinity).
-/
lemma f_continuous (i d r : ℝ) (hi : 0 < i) :
  ContinuousOn (f i d r) (Set.Ici 0) := by
  apply_rules [ ContinuousOn.sub, ContinuousOn.add, ContinuousOn.mul, continuousOn_const, continuousOn_id, ContinuousOn.rpow ] ; norm_num [ * ];
  · exact fun x hx => Or.inl <| ne_of_gt <| inv_pos.mpr <| by positivity;
  · exact fun x hx => Or.inl <| ne_of_gt <| inv_pos.mpr <| add_pos zero_lt_one hi;
  · exact fun x hx => Or.inr ( by linarith [ Set.mem_Ici.mp hx ] );
  · exact fun x hx => Or.inl <| ne_of_gt <| inv_pos.mpr <| add_pos zero_lt_one hi;
  · exact fun x hx => Or.inl <| ne_of_gt <| inv_pos.mpr <| add_pos zero_lt_one hi

/-
The function g(n) has at most one root.
-/
lemma g_at_most_one_root (i d r : ℝ) (hi : 0 < i) (hr : 0 < r) :
  Set.Subsingleton {n | g i d r n = 0} := by
  have h_subsingleton : ∀ n1 n2 : ℝ, g i d r n1 = 0 → g i d r n2 = 0 → n1 = n2 := by
    intros n1 n2 hn1 hn2
    have h_logv_ne_zero : Real.log (v_def i) ≠ 0 := by
      exact ne_of_lt ( Real.log_neg ( by exact inv_pos.mpr ( by linarith ) ) ( by exact inv_lt_one_of_one_lt₀ ( by linarith ) ) );
    unfold g at *;
    unfold S K at *;
    by_cases h : r / i = 1 <;> simp_all +decide;
    · cases hn1 <;> linarith;
    · exact mul_left_cancel₀ ( show ( r / i - 1 ) * Real.log ( v_def i ) ≠ 0 from mul_ne_zero ( sub_ne_zero_of_ne h ) ( by aesop ) ) ( by linarith );
  tauto

/-
If a continuous function starts positive and tends to a negative limit, it has a positive root.
-/
lemma exists_pos_root_of_limits
  {f : ℝ → ℝ} {L : ℝ}
  (hcont : ContinuousOn f (Set.Ici 0))
  (h0 : 0 < f 0)
  (hlim : Filter.Tendsto f Filter.atTop (nhds L))
  (hL : L < 0) :
  ∃ x > 0, f x = 0 := by
  -- Since $f(M) < 0$ and $f$ is continuous on $[0, M]$, by the Intermediate Value Theorem, there exists $c \in (0, M)$ such that $f(c) = 0$.
  have h_ivt : ∃ c ∈ Set.Ioo 0 (Classical.choose (Filter.eventually_atTop.mp (hlim.eventually (gt_mem_nhds hL)))), f c = 0 := by
    apply_rules [ intermediate_value_Ioo' ];
    · have := Classical.choose_spec ( Filter.eventually_atTop.mp ( hlim.eventually ( gt_mem_nhds hL ) ) );
      contrapose! this;
      exact ⟨ 0, by linarith, by linarith ⟩;
    · exact hcont.mono ( Set.Icc_subset_Ici_self );
    · exact ⟨ by linarith [ Classical.choose_spec ( Filter.eventually_atTop.mp ( hlim.eventually ( gt_mem_nhds hL ) ) ) ( Classical.choose ( Filter.eventually_atTop.mp ( hlim.eventually ( gt_mem_nhds hL ) ) ) ) le_rfl ], h0 ⟩;
  exact ⟨ h_ivt.choose, h_ivt.choose_spec.1.1, h_ivt.choose_spec.2 ⟩

/-
If the derivative of a differentiable function is never zero on a convex set, then the function is injective on that set.
-/
lemma injOn_of_deriv_ne_zero {f : ℝ → ℝ} {I : Set ℝ}
  (h_conv : Convex ℝ I)
  (h_diff : DifferentiableOn ℝ f I)
  (h_deriv : ∀ x ∈ I, deriv f x ≠ 0) :
  Set.InjOn f I := by
    intro x hx y hy hxy; cases eq_or_ne x y <;> simp_all +decide
    cases' lt_or_gt_of_ne ‹_› with h h;
    · have := exists_deriv_eq_slope f h;
      exact absurd ( this ( h_diff.continuousOn.mono ( by exact fun z hz => h_conv.ordConnected.out hx hy ⟨ hz.1, hz.2 ⟩ ) ) ( h_diff.mono ( by exact fun z hz => h_conv.ordConnected.out hx hy ⟨ hz.1.le, hz.2.le ⟩ ) ) ) ( by rintro ⟨ c, ⟨ hxc, hcy ⟩, hcd ⟩ ; exact h_deriv c ( h_conv.ordConnected.out hx hy ⟨ hxc.le, hcy.le ⟩ ) ( by rw [ hcd, hxy, sub_self, zero_div ] ) );
    · have := exists_deriv_eq_slope f h;
      exact absurd ( this ( by exact ContinuousOn.mono h_diff.continuousOn fun z hz => h_conv.ordConnected.out hy hx ⟨ by linarith [ hz.1 ], by linarith [ hz.2 ] ⟩ ) ( by exact DifferentiableOn.mono h_diff fun z hz => h_conv.ordConnected.out hy hx ⟨ by linarith [ hz.1 ], by linarith [ hz.2 ] ⟩ ) ) ( by rintro ⟨ c, ⟨ h₁, h₂ ⟩, h₃ ⟩ ; exact h_deriv c ( h_conv.ordConnected.out hy hx ⟨ by linarith, by linarith ⟩ ) <| by rw [ h₃, hxy, sub_self, zero_div ] )

/-
If a function is continuous on [a, b], differentiable on (a, b), and has no critical points in (a, b), then it is injective on [a, b].
-/
lemma injOn_of_deriv_ne_zero_Icc {f : ℝ → ℝ} {a b : ℝ}
  (hcont : ContinuousOn f (Set.Icc a b))
  (hderiv : ∀ x ∈ Set.Ioo a b, deriv f x ≠ 0) :
  Set.InjOn f (Set.Icc a b) := by
  intro x hx y hy hxy
  by_contra h_ne
  have h_lt : x < y ∨ y < x := ne_iff_lt_or_gt.mp h_ne
  cases h_lt with
  | inl h_lt =>
    have h_rolle : ∃ c ∈ Set.Ioo x y, deriv f c = 0 := by
      apply exists_deriv_eq_zero h_lt
      · exact hcont.mono (Set.Icc_subset_Icc hx.1 hy.2)
      · exact hxy
    obtain ⟨c, hc, hc_deriv⟩ := h_rolle
    have hc_mem : c ∈ Set.Ioo a b := ⟨lt_of_le_of_lt hx.1 hc.1, lt_of_lt_of_le hc.2 hy.2⟩
    exact hderiv c hc_mem hc_deriv
  | inr h_lt =>
    have h_rolle : ∃ c ∈ Set.Ioo y x, deriv f c = 0 := by
      apply exists_deriv_eq_zero h_lt
      · exact hcont.mono (Set.Icc_subset_Icc hy.1 hx.2)
      · exact hxy.symm
    obtain ⟨c, hc, hc_deriv⟩ := h_rolle
    have hc_mem : c ∈ Set.Ioo a b := ⟨lt_of_le_of_lt hy.1 hc.1, lt_of_lt_of_le hc.2 hx.2⟩
    exact hderiv c hc_mem hc_deriv

/-
If a function is continuous on [a, infinity), differentiable on (a, infinity), and has no critical points in (a, infinity), then it is injective on [a, infinity).
-/
lemma injOn_Ici_of_deriv_ne_zero {f : ℝ → ℝ} {a : ℝ}
  (hcont : ContinuousOn f (Set.Ici a))
  (hderiv : ∀ x ∈ Set.Ioi a, deriv f x ≠ 0) :
  Set.InjOn f (Set.Ici a) := by
  intro x hx y hy hxy
  by_contra h_ne
  have h_lt : x < y ∨ y < x := ne_iff_lt_or_gt.mp h_ne
  cases h_lt with
  | inl h_lt =>
    have h_rolle : ∃ c ∈ Set.Ioo x y, deriv f c = 0 := by
      apply exists_deriv_eq_zero h_lt
      · exact hcont.mono (Set.Icc_subset_Ici_self.trans (Set.Ici_subset_Ici.mpr hx))
      · exact hxy
    obtain ⟨c, hc, hc_deriv⟩ := h_rolle
    have hc_mem : c ∈ Set.Ioi a := lt_of_le_of_lt hx hc.1
    exact hderiv c hc_mem hc_deriv
  | inr h_lt =>
    have h_rolle : ∃ c ∈ Set.Ioo y x, deriv f c = 0 := by
      apply exists_deriv_eq_zero h_lt
      · exact hcont.mono (Set.Icc_subset_Ici_self.trans (Set.Ici_subset_Ici.mpr hy))
      · exact hxy.symm
    obtain ⟨c, hc, hc_deriv⟩ := h_rolle
    have hc_mem : c ∈ Set.Ioi a := lt_of_le_of_lt hy hc.1
    exact hderiv c hc_mem hc_deriv

/-
If a function has a root between u and v, starts positive at u, and has no critical points, it must be negative at v.
-/
lemma root_between_implies_end_sign_Icc {f : ℝ → ℝ} {u v r : ℝ}
  (huv : u < v)
  (hr : r ∈ Set.Ioo u v)
  (hcont : ContinuousOn f (Set.Icc u v))
  (hderiv : ∀ x ∈ Set.Ioo u v, deriv f x ≠ 0)
  (hu : 0 < f u)
  (hr_root : f r = 0) :
  f v < 0 := by
  -- Since $f$ is injective on $[u, v]$, it must be strictly monotonic on this interval.
  have h_monotone : StrictAntiOn f (Set.Icc u v) ∨ StrictMonoOn f (Set.Icc u v) := by
    have h_inj : Set.InjOn f (Set.Icc u v) := by
      apply_rules [ injOn_of_deriv_ne_zero_Icc ]
    have h_monotone : ContinuousOn f (Set.Icc u v) → StrictMonoOn f (Set.Icc u v) ∨ StrictAntiOn f (Set.Icc u v) := by
      intro h_cont
      have h_inj : Set.InjOn f (Set.Icc u v) := h_inj
      have h_monotone : ContinuousOn f (Set.Icc u v) → StrictMonoOn f (Set.Icc u v) ∨ StrictAntiOn f (Set.Icc u v) := by
        have h_monotone_aux : ∀ {a b : ℝ}, a ≤ b → ContinuousOn f (Set.Icc a b) → Set.InjOn f (Set.Icc a b) → StrictMonoOn f (Set.Icc a b) ∨ StrictAntiOn f (Set.Icc a b) := by
          exact fun {a b} a_1 a_2 a_3 ↦ ContinuousOn.strictMonoOn_of_injOn_Icc' a_1 a_2 a_3
        exact fun _ => h_monotone_aux huv.le h_cont h_inj
      exact h_monotone h_cont;
    exact Or.symm ( h_monotone hcont );
  cases' h_monotone with h h;
  · linarith [ h ( show u ∈ Set.Icc u v by constructor <;> linarith ) ( show v ∈ Set.Icc u v by constructor <;> linarith ) huv, h ( show r ∈ Set.Icc u v by constructor <;> linarith [ hr.1, hr.2 ] ) ( show v ∈ Set.Icc u v by constructor <;> linarith ) hr.2 ];
  · linarith [ h ( show u ∈ Set.Icc u v by constructor <;> linarith ) ( show r ∈ Set.Icc u v by constructor <;> linarith [ hr.1, hr.2 ] ) hr.1 ]

/-
If a function has a root r > c, starts negative at c, and has no critical points for x > c, then its limit at infinity is non-negative.
-/
lemma root_implies_limit_ge_zero {f : ℝ → ℝ} {c r L : ℝ}
  (hcr : c < r)
  (hcont : ContinuousOn f (Set.Ici c))
  (hdiff : DifferentiableOn ℝ f (Set.Ioi c))
  (hderiv : ∀ x ∈ Set.Ioi c, deriv f x ≠ 0)
  (hc : f c < 0)
  (hr : f r = 0)
  (hlim : Filter.Tendsto f Filter.atTop (nhds L)) :
  L ≥ 0 := by
  -- Since $f$ is injective on $[c, \infty)$, it must be strictly monotonic.
  have h_mono : StrictMonoOn f (Set.Ici c) ∨ StrictAntiOn f (Set.Ici c) := by
    -- Apply the lemma that states if a function is continuous on [a, infinity), differentiable on (a, infinity), and has no critical points in (a, infinity), then it is injective on [a, infinity).
    have h_inj : Set.InjOn f (Set.Ici c) := by
      have h_diff : DifferentiableOn ℝ f (Set.Ioi c) := hdiff
      have h_cont : ContinuousOn f (Set.Ici c) := hcont
      exact injOn_Ici_of_deriv_ne_zero h_cont hderiv;
    -- Apply the fact that a continuous injective function on an interval is strictly monotonic.
    have h_monotone : ∀ {a b : ℝ}, a ≤ b → ContinuousOn f (Set.Icc a b) → Set.InjOn f (Set.Icc a b) → StrictMonoOn f (Set.Icc a b) ∨ StrictAntiOn f (Set.Icc a b) := by
      exact fun {a b} a_1 a_2 a_3 ↦ ContinuousOn.strictMonoOn_of_injOn_Icc' a_1 a_2 a_3;
    contrapose! h_monotone;
    simp_all +decide [ StrictMonoOn, StrictAntiOn ];
    obtain ⟨ ⟨ x, hx₁, y, hy₁, hxy, h ⟩, ⟨ u, hu₁, v, hv₁, huv, h' ⟩ ⟩ := h_monotone;
    use Min.min x u, Max.max y v;
    refine' ⟨ _, _, _, _ ⟩;
    · cases max_cases y v <;> cases min_cases x u <;> linarith;
    · exact hcont.mono ( fun z hz => by cases max_cases y v <;> cases min_cases x u <;> exact Set.mem_Ici.mpr <| by linarith [ hz.1, hz.2 ] );
    · exact h_inj.mono ( Set.Icc_subset_Ici_self.trans ( Set.Ici_subset_Ici.2 ( by cases min_cases x u <;> cases max_cases y v <;> linarith ) ) );
    · exact ⟨ ⟨ x, by cases min_cases x u <;> linarith, by cases max_cases y v <;> linarith, y, by cases min_cases x u <;> linarith, by cases max_cases y v <;> linarith, hxy, h ⟩, ⟨ u, by cases min_cases x u <;> linarith, by cases max_cases y v <;> linarith, v, by cases min_cases x u <;> linarith, by cases max_cases y v <;> linarith, huv, h' ⟩ ⟩;
  cases' h_mono with h h;
  · exact le_of_tendsto_of_tendsto tendsto_const_nhds hlim ( Filter.eventually_atTop.mpr ⟨ r, fun x hx => by linarith [ h.le_iff_le ( show c ≤ r by linarith ) ( show c ≤ x by linarith ) |>.2 hx ] ⟩ );
  · linarith [ h ( show c ∈ Set.Ici c by norm_num ) ( show r ∈ Set.Ici c by norm_num; linarith ) hcr ]

/-
If f starts positive, tends to a negative limit, and has at most one positive critical point, then f has at most one positive root.
-/
lemma at_most_one_root_of_single_critical_point
  {f : ℝ → ℝ} {f' : ℝ → ℝ} {L : ℝ}
  (hcont : ContinuousOn f (Set.Ici 0))
  (hderiv : ∀ x ∈ Set.Ioi 0, HasDerivAt f (f' x) x)
  (h0 : 0 < f 0)
  (hlim : Filter.Tendsto f Filter.atTop (nhds L))
  (hL : L < 0)
  (hcrit : Set.Subsingleton {x | 0 < x ∧ f' x = 0}) :
  Set.Subsingleton {x | 0 < x ∧ f x = 0} := by
  intro x hx y hy;
  -- Suppose there are two distinct roots a, b with 0 < a < b.
  by_contra hxy
  obtain ⟨a, b, hab⟩ : ∃ a b : ℝ, 0 < a ∧ a < b ∧ f a = 0 ∧ f b = 0 := by
    cases lt_or_gt_of_ne hxy <;> [ exact ⟨ x, y, hx.1, ‹_›, hx.2, hy.2 ⟩ ; exact ⟨ y, x, hy.1, ‹_›, hy.2, hx.2 ⟩ ];
  -- By Rolle's Theorem, there exists a critical point c in (a, b).
  obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo a b, f' c = 0 := by
    have := exists_deriv_eq_slope f hab.2.1;
    exact this ( hcont.mono <| by intro x hx; exact hx.1.trans' hab.1.le ) ( fun x hx => ( hderiv x <| by norm_num; linarith [ hx.1 ] ) |> HasDerivAt.differentiableAt |> DifferentiableAt.differentiableWithinAt ) |> fun ⟨ c, hc₁, hc₂ ⟩ => ⟨ c, hc₁, by rw [ ← hderiv c ( by norm_num; linarith [ hc₁.1 ] ) |> HasDerivAt.deriv, hc₂, hab.2.2.2, hab.2.2.1, sub_self, zero_div ] ⟩;
  -- Since $c$ is the unique positive critical point, we have $f'(x) \neq 0$ for all $x \in (0, c) \cup (c, \infty)$.
  have h_deriv_ne_zero : ∀ x ∈ Set.Ioi 0, x ≠ c → f' x ≠ 0 := by
    exact fun x hx hx' hx'' => hx' <| hcrit ⟨ hx, hx'' ⟩ ⟨ by linarith [ hx.out, hc.1.1 ], hc.2 ⟩;
  -- Apply root_between_implies_end_sign_Icc with u=0, v=c, r=a.
  have h_sign_c : f c < 0 := by
    have h_sign_c : f c < 0 := by
      have h_cont : ContinuousOn f (Set.Icc 0 c) := by
        exact hcont.mono ( Set.Icc_subset_Ici_self )
      have h_diff : DifferentiableOn ℝ f (Set.Ioo 0 c) := by
        exact fun x hx => ( hderiv x hx.1 |> HasDerivAt.differentiableAt |> DifferentiableAt.differentiableWithinAt )
      have h_deriv_ne_zero : ∀ x ∈ Set.Ioo 0 c, deriv f x ≠ 0 := by
        exact fun x hx => by have := hderiv x hx.1; have := this.deriv; aesop;
      have h_sign_c : f c < 0 := by
        have h_root_between : ∃ r ∈ Set.Ioo 0 c, f r = 0 := by
          exact ⟨ a, ⟨ by linarith, by linarith [ hc.1.1 ] ⟩, hab.2.2.1 ⟩
        obtain ⟨ r, hr₁, hr₂ ⟩ := h_root_between; exact root_between_implies_end_sign_Icc ( by linarith [ hr₁.1, hr₁.2 ] ) hr₁ h_cont h_deriv_ne_zero h0 hr₂;
      exact h_sign_c;
    linarith;
  -- Apply root_implies_limit_ge_zero with c=c, r=b.
  have h_limit_ge_zero : L ≥ 0 := by
    apply root_implies_limit_ge_zero;
    exact hc.1.2;
    exact hcont.mono ( Set.Ici_subset_Ici.mpr ( by linarith [ hc.1.1 ] ) );
    · exact fun x hx => ( hderiv x <| lt_trans ( lt_trans hab.1 hc.1.1 ) hx ) |> HasDerivAt.differentiableAt |> DifferentiableAt.differentiableWithinAt;
    · exact fun x hx => by rw [ hderiv x ( show 0 < x from lt_trans ( lt_trans hab.1 hc.1.1 ) hx ) |> HasDerivAt.deriv ] ; exact h_deriv_ne_zero x ( show 0 < x from lt_trans ( lt_trans hab.1 hc.1.1 ) hx ) ( ne_of_gt hx ) ;
    · linarith;
    · linarith;
    · exact hlim;
  linarith


/-
There exists a unique positive real number n satisfying the equation.
-/
theorem unique_solution_n (i d r : ℝ)
  (hd : 0 < d) (hi : 0 < i) (hr : 0 < r)
  (hdi : d < 1 + 1 / i) :
  ∃! n : ℝ, 0 < n ∧
    let v := (1 + i)⁻¹
    d * (r * ((1 - v ^ n) / i) + v ^ n) -
    (r * (v * (n * v ^ (n + 1) - (n + 1) * v ^ n + 1) / (v - 1) ^ 2) + n * v ^ n) = 0 := by
      have h_cont : ContinuousOn (f i d r) (Set.Ici 0) := by
        exact f_continuous i d r hi
      have h_diff : ∀ x ∈ Set.Ioi 0, HasDerivAt (f i d r) (v_def i ^ x * g i d r x) x :=
        fun x a ↦ f_deriv i d r x hi
      have h_start_pos : 0 < f i d r 0 := by
        unfold f; norm_num [ v_def ] ; exact hd
      have h_tendsto_neg : Filter.Tendsto (f i d r) Filter.atTop (nhds (C i d r)) := by
        exact f_tendsto_atTop i d r hi
      have h_lim_neg : C i d r < 0 := by
        exact C_neg i d r hi hr hdi;
      -- By definition of $f$, we know that $f$ has at most one positive critical point.
      have h_at_most_one_critical : Set.Subsingleton {x | 0 < x ∧ v_def i ^ x * g i d r x = 0} := by
        have h_at_most_one_critical : Set.Subsingleton {x | 0 < x ∧ g i d r x = 0} := by
          have h_at_most_one_critical : Set.Subsingleton {x | g i d r x = 0} := by
            exact g_at_most_one_root i d r hi hr;
          exact fun x hx y hy => h_at_most_one_critical hx.2 hy.2;
        simp_all +decide
        exact fun x hx y hy => h_at_most_one_critical
          ⟨ hx.1, hx.2.resolve_left <| ne_of_gt <| Real.rpow_pos_of_pos ( inv_pos.mpr <| by linarith ) _ ⟩
          ⟨ hy.1, hy.2.resolve_left <| ne_of_gt <| Real.rpow_pos_of_pos ( inv_pos.mpr <| by linarith ) _ ⟩;
      -- By definition of $f$, we know that $f$ has at most one positive root.
      have h_at_most_one_root : Set.Subsingleton {x | 0 < x ∧ f i d r x = 0} := by
        apply at_most_one_root_of_single_critical_point
            h_cont h_diff h_start_pos h_tendsto_neg h_lim_neg h_at_most_one_critical;
      -- By definition of $f$, we know that $f$ has at least one positive root.
      have h_at_least_one_root : ∃ x > 0, f i d r x = 0 := by
        apply exists_pos_root_of_limits h_cont h_start_pos h_tendsto_neg h_lim_neg;
      exact ⟨ h_at_least_one_root.choose, h_at_least_one_root.choose_spec,
        fun x hx => h_at_most_one_root hx h_at_least_one_root.choose_spec ⟩

end AriMagic
