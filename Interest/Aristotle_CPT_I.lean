/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c0e1f778-b5c4-400d-b2b5-f7360dc79041
-/

/-
We define the function `f` and prove that under
the given conditions (n ≥ 2, 1 < d < n, r > 0),
there exists a unique positive real number v such that f(v) = 0.
The proof proceeds by analyzing the auxiliary function h(v) = N(v)/D(v),
showing it is strictly increasing and maps (0, ∞) to (1, n).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the function f(v) involved in the unique root problem.
-/
noncomputable def f (n : ℕ) (d r v : ℝ) : ℝ :=
  d * (r * (Finset.sum (Finset.Icc 1 n) (fun k => v ^ k)) + v ^ n)
  - (r * (Finset.sum (Finset.Icc 1 n) (fun k => (k : ℝ) * v ^ k)) + (n : ℝ) * v ^ n)

/-
Definition of the auxiliary function h(v) = N(v)/D(v).
-/
noncomputable def h (n : ℕ) (r v : ℝ) : ℝ :=
  (r * (Finset.sum (Finset.Icc 1 n) (fun k => (k : ℝ) * v ^ k)) + (n : ℝ) * v ^ n) /
  (r * (Finset.sum (Finset.Icc 1 n) (fun k => v ^ k)) + v ^ n)

/-
Numerator and denominator of h(v).
-/
noncomputable def num_h (n : ℕ) (r v : ℝ) : ℝ :=
  r * (Finset.sum (Finset.Icc 1 n) (fun k => (k : ℝ) * v ^ k)) + (n : ℝ) * v ^ n

noncomputable def den_h (n : ℕ) (r v : ℝ) : ℝ :=
  r * (Finset.sum (Finset.Icc 1 n) (fun k => v ^ k)) + v ^ n

/-
Rewrite h(v) as a quotient of sums with coefficients.
-/
noncomputable def coeff (n : ℕ) (r : ℝ) (k : ℕ) : ℝ := if k = n then r + 1 else r

lemma h_eq_quotient (n : ℕ) (hn : n ≥ 2) (r v : ℝ) :
  h n r v = (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * k * v ^ k)) /
            (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * v ^ k)) := by
  -- By definition of $h$, we can rewrite the numerator and denominator as sums with coefficients.
  simp [h, coeff];
  simp +decide [ Finset.sum_ite, add_mul, mul_assoc, Finset.sum_add_distrib ];
  simp +decide [ ← Finset.mul_sum, Finset.filter_eq', Finset.filter_ne' ];
  erw [ Finset.sum_Ico_eq_sub, Finset.sum_Ico_eq_sub ] <;> norm_num [ show n ≥ 1 by linarith ];
  rw [ Finset.sum_Ico_eq_sub, Finset.sum_Ico_eq_sub _ ] <;> norm_num [ Finset.sum_range_succ ] ; ring;
  · exact Nat.one_le_of_lt hn;
  · exact Nat.one_le_of_lt hn

/-
The auxiliary expression corresponding to the numerator of the derivative of h is positive.
-/
noncomputable def h_deriv_numerator_aux (n : ℕ) (r v : ℝ) : ℝ :=
  (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * (k : ℝ)^2 * v^(k-1))) * (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * v^k)) -
  (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * (k : ℝ) * v^k)) * (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * (k : ℝ) * v^(k-1)))

lemma h_deriv_numerator_aux_pos (n : ℕ) (hn : n ≥ 2) (r v : ℝ) (hr : r > 0) (hv : v > 0) :
  h_deriv_numerator_aux n r v > 0 := by
    revert n r v;
    -- Let's simplify the expression for the numerator.
    intro n hn r v hr hv
    simp [h_deriv_numerator_aux];
    -- By the properties of the quadratic form and the positive coefficients, the difference between the right-hand side and the left-hand side is positive.
    have h_diff_pos : ∑ x ∈ Finset.Icc 1 n, ∑ y ∈ Finset.Icc 1 n, coeff n r x * coeff n r y * (x - y) ^ 2 * v ^ (x - 1) * v ^ (y - 1) > 0 := by
      refine' lt_of_lt_of_le _ ( Finset.single_le_sum ( fun x hx => Finset.sum_nonneg fun y hy => _ ) ( Finset.left_mem_Icc.mpr ( by linarith ) ) );
      · refine' lt_of_lt_of_le _ ( Finset.single_le_sum ( fun x hx => _ ) ( show 2 ∈ Finset.Icc 1 n by norm_num; linarith ) ) <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc), coeff ];
        · split_ifs <;> positivity;
        · split_ifs <;> positivity;
      · exact mul_nonneg ( mul_nonneg ( mul_nonneg ( mul_nonneg ( by unfold coeff; split_ifs <;> positivity ) ( by unfold coeff; split_ifs <;> positivity ) ) ( sq_nonneg _ ) ) ( pow_nonneg hv.le _ ) ) ( pow_nonneg hv.le _ );
    -- Expanding the left-hand side of the inequality.
    have h_expand : ∑ x ∈ Finset.Icc 1 n, ∑ y ∈ Finset.Icc 1 n, coeff n r x * coeff n r y * (x - y) ^ 2 * v ^ (x - 1) * v ^ (y - 1) = (∑ x ∈ Finset.Icc 1 n, coeff n r x * x ^ 2 * v ^ (x - 1)) * (∑ y ∈ Finset.Icc 1 n, coeff n r y * v ^ (y - 1)) + (∑ x ∈ Finset.Icc 1 n, coeff n r x * v ^ (x - 1)) * (∑ y ∈ Finset.Icc 1 n, coeff n r y * y ^ 2 * v ^ (y - 1)) - 2 * (∑ x ∈ Finset.Icc 1 n, coeff n r x * x * v ^ (x - 1)) * (∑ y ∈ Finset.Icc 1 n, coeff n r y * y * v ^ (y - 1)) := by
      norm_num [ Finset.mul_sum _ _ _, Finset.sum_mul, mul_assoc, mul_comm, mul_left_comm, sub_sq ];
      simpa only [ ← Finset.sum_add_distrib, ← Finset.sum_sub_distrib ] using Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by ring;
    -- By combining terms, we can factor out common factors and simplify the expression.
    have h_simplify : (∑ x ∈ Finset.Icc 1 n, coeff n r x * x * v ^ x) = v * (∑ x ∈ Finset.Icc 1 n, coeff n r x * x * v ^ (x - 1)) ∧ (∑ x ∈ Finset.Icc 1 n, coeff n r x * v ^ x) = v * (∑ x ∈ Finset.Icc 1 n, coeff n r x * v ^ (x - 1)) := by
      exact ⟨ by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun x hx => by rw [ show v ^ x = v * v ^ ( x - 1 ) by rw [ ← pow_succ', Nat.sub_add_cancel ( Finset.mem_Icc.mp hx |>.1 ) ] ] ; ring, by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun x hx => by rw [ show v ^ x = v * v ^ ( x - 1 ) by rw [ ← pow_succ', Nat.sub_add_cancel ( Finset.mem_Icc.mp hx |>.1 ) ] ] ; ring ⟩;
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    linarith

/-
The denominator of h is positive for v > 0.
-/
lemma den_h_pos (n : ℕ) (r v : ℝ) (hr : r > 0) (hv : v > 0) :
  den_h n r v > 0 := by
    exact add_pos_of_nonneg_of_pos ( mul_nonneg hr.le <| Finset.sum_nonneg fun _ _ => pow_nonneg hv.le _ ) <| pow_pos hv _

/-
h is strictly increasing on (0, ∞).
-/
lemma h_strict_mono (n : ℕ) (hn : n ≥ 2) (r : ℝ) (hr : r > 0) :
  StrictMonoOn (h n r) (Set.Ioi 0) := by
    -- The derivative of $h(v)$ is given by the expression we obtained.
    have h_deriv : ∀ v, v > 0 → deriv (h n r) v = h_deriv_numerator_aux n r v / (den_h n r v)^2 := by
      intro v hv_pos
      have h_deriv_def : deriv (h n r) v = (deriv (fun v => Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * k * v ^ k)) v * Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * v ^ k) - Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * k * v ^ k) * deriv (fun v => Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * v ^ k)) v) / (Finset.sum (Finset.Icc 1 n) (fun k => coeff n r k * v ^ k))^2 := by
        rw [ show h n r = fun v => ( ∑ k ∈ Finset.Icc 1 n, coeff n r k * ( k : ℝ ) * v ^ k ) / ( ∑ k ∈ Finset.Icc 1 n, coeff n r k * v ^ k ) from funext fun v => h_eq_quotient n hn r v ];
        apply_rules [ deriv_div ];
        · norm_num;
        · norm_num;
        · exact ne_of_gt <| Finset.sum_pos ( fun x hx => mul_pos ( by unfold coeff; split_ifs <;> linarith ) <| pow_pos hv_pos _ ) <| Finset.nonempty_Icc.mpr <| by linarith;
      convert h_deriv_def using 2 ; norm_num [ Finset.sum_apply, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, pow_succ' ] ; ring_nf;
      · simp +decide [ h_deriv_numerator_aux, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _];
      · unfold den_h;
        unfold coeff; norm_num [ Finset.sum_add_distrib, add_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ;
        rw [ Finset.sum_eq_add_sum_diff_singleton ( show n ∈ Finset.Icc 1 n from Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ] ; ring_nf;
        rw [ Finset.sum_eq_add_sum_diff_singleton ( show n ∈ Finset.Icc 1 n from Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ] ; norm_num ; ring_nf;
        rw [ Finset.sum_congr rfl fun x hx => if_neg <| by aesop ];
    -- Since the derivative of $h(v)$ is positive for all $v > 0$, $h(v)$ is strictly increasing on $(0, \infty)$.
    have h_deriv_pos : ∀ v, v > 0 → 0 < deriv (h n r) v := by
      exact fun v hv => h_deriv v hv ▸ div_pos ( h_deriv_numerator_aux_pos n hn r v hr hv ) ( sq_pos_of_pos ( den_h_pos n r v hr hv ) );
    -- Apply the fact that if the derivative of a function is positive on an interval, then the function is strictly increasing on that interval.
    apply strictMonoOn_of_deriv_pos;
    · exact convex_Ioi 0;
    · exact continuousOn_of_forall_continuousAt fun v hv => differentiableAt_of_deriv_ne_zero ( ne_of_gt ( h_deriv_pos v hv ) ) |> DifferentiableAt.continuousAt;
    · aesop

/-
h(v) tends to 1 as v approaches 0 from the right.
-/
lemma h_tendsto_zero (n : ℕ) (hn : n ≥ 2) (r : ℝ) (hr : r > 0) :
  Filter.Tendsto (h n r) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1) := by
    -- We'll use the fact that $h(v)$ is a quotient of two functions, both of which converge to $0$ as $v \to 0^+$.
    have h_num_denom : Filter.Tendsto (fun v : ℝ => (r * (∑ k ∈ Finset.Icc 1 n, (k : ℝ) * v ^ k) + n * v ^ n) / v) (nhdsWithin 0 (Set.Ioi 0)) (nhds r) ∧ Filter.Tendsto (fun v : ℝ => (r * (∑ k ∈ Finset.Icc 1 n, v ^ k) + v ^ n) / v) (nhdsWithin 0 (Set.Ioi 0)) (nhds r) := by
      -- We can factor out $v$ in the numerator and denominator.
      suffices h_factor : Filter.Tendsto (fun v : ℝ => r * (∑ k ∈ Finset.Icc 1 n, (k : ℝ) * v ^ (k - 1)) + n * v ^ (n - 1)) (nhdsWithin 0 (Set.Ioi 0)) (nhds r) ∧ Filter.Tendsto (fun v : ℝ => r * (∑ k ∈ Finset.Icc 1 n, v ^ (k - 1)) + v ^ (n - 1)) (nhdsWithin 0 (Set.Ioi 0)) (nhds r) by
        refine' ⟨ h_factor.1.congr' _, h_factor.2.congr' _ ⟩ <;> filter_upwards [ self_mem_nhdsWithin ] with v hv <;> simp +decide [ Finset.mul_sum _ _  ];
        · rw [ eq_div_iff hv.out.ne' ] ; induction hn <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc), pow_succ' ] ; ring;
          rename_i k hk ih; rw [ show ( ∑ x ∈ Finset.Ioc 0 k, r * ( ( x : ℝ ) * v ^ x ) ) = ( ∑ x ∈ Finset.Ioc 0 k, r * ( ( x : ℝ ) * v ^ ( x - 1 ) ) ) * v by rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by cases ‹ℕ› <;> simp +decide [ pow_succ, mul_assoc, mul_comm, mul_left_comm ] ] ; ring;
        · rw [ eq_div_iff hv.out.ne' ] ; induction hn <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] ; ring;
          rw [ show ( ∑ k ∈ Finset.Ioc 0 _, r * v ^ k ) = ( ∑ k ∈ Finset.Ioc 0 _, r * v ^ ( k - 1 ) ) * v by rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_congr rfl fun x hx => by rw [ mul_assoc, ← pow_succ, Nat.sub_add_cancel ( Finset.mem_Ioc.mp hx |>.1 ) ] ] ; ring;
      constructor <;> refine' tendsto_nhdsWithin_of_tendsto_nhds _;
      · refine' Continuous.tendsto' _ _ _ _;
        · fun_prop;
        · rcases n with ( _ | _ | n ) <;> norm_num [ Finset.sum_range_succ' ] at *;
          erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ];
      · refine' Continuous.tendsto' _ _ _ _;
        · fun_prop;
        · rcases n with ( _ | _ | n ) <;> norm_num [ Finset.sum_range_succ' ] at *;
          erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ Finset.sum_range_succ' ];
    have := h_num_denom.1.div h_num_denom.2;
    simpa [ hr.ne' ] using this hr.ne' |> Filter.Tendsto.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with x hx using by rw [ Pi.div_apply, div_div_div_cancel_right₀ hx.out.ne' ] ; exact by unfold h; ring )

/-
h(v) tends to n as v approaches infinity.
-/
lemma h_tendsto_atTop (n : ℕ) (hn : n ≥ 2) (r : ℝ) (hr : r > 0) :
  Filter.Tendsto (h n r) Filter.atTop (nhds n) := by
    unfold h;
    -- Divide numerator and denominator by $v^n$.
    have h_div : Filter.Tendsto (fun v : ℝ =>
      (r * (∑ k ∈ Finset.Icc 1 n, (k : ℝ) / v ^ (n - k)) + n) / (r * (∑ k ∈ Finset.Icc 1 n, (1 : ℝ) / v ^ (n - k)) + 1))
        Filter.atTop (nhds ((n : ℝ))) := by
      -- As $v \to \infty$, the terms $\frac{k}{v^{n-k}}$ and $\frac{1}{v^{n-k}}$ tend to $0$ for $k < n$.
      have h_tendsto_zero : ∀ k ∈ Finset.Icc 1 n, k < n →
        Filter.Tendsto (fun v : ℝ => (k : ℝ) / v ^ (n - k)) Filter.atTop (nhds 0) ∧
        Filter.Tendsto (fun v : ℝ => (1 : ℝ) / v ^ (n - k)) Filter.atTop (nhds 0) := by
        exact fun k hk₁ hk₂ => ⟨ tendsto_const_nhds.div_atTop
          (Filter.tendsto_pow_atTop ( Nat.sub_ne_zero_of_lt hk₂ ) ), tendsto_const_nhds.div_atTop
            (Filter.tendsto_pow_atTop ( Nat.sub_ne_zero_of_lt hk₂ ) ) ⟩;
      -- Apply the fact that the sum of limits holds in the topology of pointwise convergence.
      have h_sum_tendsto_zero : Filter.Tendsto (fun v : ℝ => ∑ k ∈ Finset.Icc 1 n, (k : ℝ) / v ^ (n - k))
        Filter.atTop (nhds (∑ k ∈ Finset.Icc 1 n, if k = n then (n : ℝ) else 0)) ∧
        Filter.Tendsto (fun v : ℝ => ∑ k ∈ Finset.Icc 1 n, (1 : ℝ) / v ^ (n - k))
          Filter.atTop (nhds (∑ k ∈ Finset.Icc 1 n, if k = n then (1 : ℝ) else 0)) := by
        apply And.intro;
        · refine' tendsto_finset_sum _ fun k hk => _;
          cases eq_or_lt_of_le ( Finset.mem_Icc.mp hk |>.2 ) <;> aesop;
        · exact tendsto_finset_sum _ fun x hx => by cases eq_or_lt_of_le ( Finset.mem_Icc.mp hx |>.2 ) <;> aesop;
      convert Filter.Tendsto.div ( Filter.Tendsto.add ( tendsto_const_nhds.mul h_sum_tendsto_zero.1 )
        tendsto_const_nhds ) ( Filter.Tendsto.add ( tendsto_const_nhds.mul h_sum_tendsto_zero.2 )
        tendsto_const_nhds ) _ using 2 <;> norm_num;
      · rw [ if_pos ( by linarith ), if_pos ( by linarith ), eq_div_iff ] <;> linarith;
      · split_ifs <;> linarith;
    refine h_div.congr' ?_;
    filter_upwards [ Filter.eventually_gt_atTop 0 ] with v hv;
    rw [ show ( ∑ k ∈ Finset.Icc 1 n, ( k : ℝ ) / v ^ ( n - k ) )
            = ( ∑ k ∈ Finset.Icc 1 n, ( k : ℝ ) * v ^ k ) / v ^ n from ?_,
         show ( ∑ k ∈ Finset.Icc 1 n, ( 1 : ℝ ) / v ^ ( n - k ) )
            = ( ∑ k ∈ Finset.Icc 1 n, v ^ k ) / v ^ n from ?_ ];
    · field_simp;
    · rw [ Finset.sum_div _ _ _ ] ;
      refine' Finset.sum_congr rfl fun x hx => _ ; rw [ div_eq_div_iff ] <;> first | positivity | ring_nf;
      rw [ ← pow_add, Nat.add_sub_of_le ( Finset.mem_Icc.mp hx |>.2 ) ];
    · rw [ Finset.sum_div _ _ _ ] ;
      refine' Finset.sum_congr rfl fun x hx => _ ; rw [ div_eq_div_iff ] <;> first | positivity | ring_nf;
      rw [ mul_assoc, ← pow_add, Nat.add_sub_of_le ( Finset.mem_Icc.mp hx |>.2 ) ]

/-
There exists a unique positive real number v such that f(v) = 0.
-/
theorem unique_root_f (n : ℕ) (hn : n ≥ 2) (d r : ℝ) (hd : d ∈ Set.Ioo 1 (n : ℝ)) (hr : r > 0) :
  ∃! v, 0 < v ∧ f n d r v = 0 := by
    -- By the Intermediate Value Theorem, since $h(v)$ is strictly increasing and continuous on $(0, \infty)$ with $h(0^+) = 1$ and $h(\infty) = n$, there exists a unique $v₀$ such that $h(v₀) = d$.
    obtain ⟨v₀, hv₀⟩ : ∃! v : ℝ, 0 < v ∧ h n r v = d := by
      have h_ivt : ∃ v ∈ Set.Ioi 0, h n r v = d := by
        have h_cont : ContinuousOn (h n r) (Set.Ioi 0) := by
          refine' ContinuousOn.div _ _ _;
          · exact Continuous.continuousOn ( by continuity );
          · exact Continuous.continuousOn ( by continuity );
          · exact fun x hx => ne_of_gt <| add_pos_of_nonneg_of_pos
              ( mul_nonneg hr.le <| Finset.sum_nonneg fun _ _ => pow_nonneg hx.out.le _ ) <| pow_pos hx.out _;
        have h_ivt : ∃ v ∈ Set.Ioi 0, h n r v > d := by
          have := h_tendsto_atTop n hn r hr;
          have := this.eventually ( lt_mem_nhds hd.2 ) ;
          have := this.and ( Filter.eventually_gt_atTop 0 ) ;
          obtain ⟨ v, hv₁, hv₂ ⟩ := this.exists; exact ⟨ v, hv₂, hv₁ ⟩ ;
        have h_ivt : ∃ v ∈ Set.Ioi 0, h n r v < d := by
          have := h_tendsto_zero n hn r hr; have := this.eventually ( gt_mem_nhds <| show 1 < d from hd.1 ) ;
          have := this.and self_mem_nhdsWithin; obtain ⟨ v, hv₁, hv₂ ⟩ := this.exists; use v; aesop;
        have h_ivt : IsConnected (Set.image (h n r) (Set.Ioi 0)) := by
          exact ⟨ Set.Nonempty.image _ ⟨ 1, by norm_num ⟩, isPreconnected_Ioi.image _ h_cont ⟩;
        exact h_ivt.Icc_subset
          ( Set.mem_image_of_mem _ <| Classical.choose_spec ( ‹∃ v ∈ Set.Ioi 0, h n r v < d› ) |>.1 )
          ( Set.mem_image_of_mem _ <| Classical.choose_spec ( ‹∃ v ∈ Set.Ioi 0, h n r v > d› ) |>.1 )
          ⟨ by linarith [ Classical.choose_spec ( ‹∃ v ∈ Set.Ioi 0, h n r v < d› ) |>.2 ],
            by linarith [ Classical.choose_spec ( ‹∃ v ∈ Set.Ioi 0, h n r v > d› ) |>.2 ] ⟩;
      obtain ⟨ v, hv₁, hv₂ ⟩ := h_ivt;
      exact ⟨ v, ⟨ hv₁, hv₂ ⟩, fun w hw => StrictMonoOn.injOn ( h_strict_mono n hn r hr ) hw.1 hv₁ <| by aesop ⟩ ;
    -- By definition of $f$, we know that $f(v) = 0$ if and only if $h(v) = d$.
    have h_equiv : ∀ v, 0 < v → (f n d r v = 0 ↔ h n r v = d) := by
      intro v hv
      simp [f, h];
      rw [ div_eq_iff ( ne_of_gt <| add_pos_of_nonneg_of_pos ( mul_nonneg hr.le
        <| Finset.sum_nonneg fun _ _ => pow_nonneg hv.le _ ) <| pow_pos hv _ ) ] ;
      constructor <;> intro <;> linarith;
    exact ⟨ v₀, ⟨ hv₀.1.1, h_equiv v₀ hv₀.1.1 |>.2 hv₀.1.2 ⟩,
      fun y hy => hv₀.2 y ⟨ hy.1, h_equiv y hy.1 |>.1 hy.2 ⟩ ⟩
